{"version":3,"file":"bsimp.module.mjs","sources":["../src/consts.mjs","../src/tools.mjs","../src/toString.mjs","../src/transforms/unwrap.mjs","../src/transforms/association.mjs","../src/transforms/absorption.mjs","../src/transforms/consensus.mjs","../src/transforms/distribute.mjs","../src/transforms/index.mjs","../src/transforms/tautology.mjs","../src/transforms/identity.mjs","../src/transforms/complement.mjs","../src/transforms/deMorgan.mjs","../src/transforms/collect.mjs","../src/simplify.mjs","../src/boolGrammar.mjs","../src/parse.mjs"],"sourcesContent":["export const AND = Symbol(' ∩ ');\nexport const OR = Symbol(' ∪ ');\nexport const NOT = Symbol('!');\n\nexport const TRUE = Symbol('TRUE');\nexport const FALSE = Symbol('FALSE');\n\nexport const KEYWORDS = { AND, OR, NOT, TRUE, FALSE, 1: TRUE, 0: FALSE };\n","import { AND, FALSE, KEYWORDS, NOT, OR, TRUE } from \"./consts.mjs\";\n\nconst OPERATORS = { [AND]: AND, [OR]: OR, [NOT]: NOT };\n\n// If an expression is an expression.  That is, it's an array with the first item being\n//  an operator.\nexport const isExpression = exp => Array.isArray(exp) && !!OPERATORS[exp[0]];\nexport const isOr = exp => isExpression(exp) && exp[0] === OR;\nexport const isAnd = exp => isExpression(exp) && exp[0] === AND;\nexport const isNot = exp => isExpression(exp) && exp[0] === NOT && !!exp[1];\nexport const isSymbol = exp => typeof exp === 'symbol';\n\n// Whether `expression` contains `subexpression`\nexport const contains = (expression, subexpression) => (\n  expression.slice(1).some(se => areEqual(se, subexpression))\n);\n\nexport const areEqual = (e1, e2, inv = true) => {\n  \n  if (inv) {\n    // treat !!EXP as EXP\n    [e1, e2] = [e1, e2].map(e => involution(e));\n  }\n  // If either are falsy, they're inequal (for our purposes)\n  if (!e1 || !e2) return false;\n  // Fastest end: if they're the same object, they're equal\n  if (e1 === e2) return true;\n  // If either is a symbol, but they're not the same object, they're inequal.\n  if (isSymbol(e1) || isSymbol(e2)) return false;\n  // If they're expressions of different lengths, they're inequal\n  if (e1.length !== e2.length) return false;\n  // If any subpart is inequal, they're inequal.\n  if (e1.some((p, i) => !areEqual(e2[i], p))) return false;\n  // If all checks pass, they're equal.\n  return true;\n};\n\n// Whether the expression contains two terms that are complements of one another.\nexport const hasComplement = (expression) => {\n  for (let p = 1; p < (expression.length - 1); p++) {\n    const P = expression[p];\n    for (let q = p + 1; q < expression.length; q++) {\n      const Q = expression[q];\n      const notQ = invert(Q);\n      if (areEqual(P, notQ)) return true;\n    }\n  }\n  return false;\n};\n\n// Expression contains one or more OR operation\nexport const hasOr = (expression) => expression.slice(1).some(isOr);\n// Expression contains one or more AND operation\nexport const hasAnd = (expression) => expression.slice(1).some(isAnd);\n\nexport const findCommon = (...exps) => {\n  const nExps = exps.length;\n  //Different operations or non-expression; return nothing.\n  if (nExps < 2 || exps.some((e) => !isExpression(e) || e[0] !== exps[0][0])) {\n    return {};\n  }\n  const terms = [];\n  exps.forEach((exp, ei) => {\n    exp.slice(1).forEach((t) => {\n      const haveCommon = terms.some((item) => {\n        if (areEqual(t, item[0])) {\n          item[1].push(ei);\n          return true;\n        }\n        return false;\n      });\n      if (!haveCommon) {\n        terms.push([t, [ei]]);\n      }\n    });\n  });\n  const common = terms.filter((t) => t[1].length === nExps).map(([T]) => T);\n  const unique = terms.reduce((r, [T, where]) => {\n    if (where.length === nExps) return r;\n    where.forEach((ei) => {\n      r[ei].push(T);\n    });\n    return r;\n  }, exps.map(() => []));\n\n  // No common values.\n  if (!common.length) return {};\n  // Return as subexpressions\n  return {\n    common,\n    unique\n  };\n};\n\nexport const without = (exp, sub) => [exp[0], ...exp.slice(1).filter(se => !areEqual(se, sub))];\n\nconst terms = {};\n\n// Create the symbol\nexport const term = name => {\n  if (isSymbol(name)) {\n    name = name.description;\n  }\n  if (!terms[name]) {\n    terms[name] = {\n      term: Symbol(name),\n      index: Object.keys(terms).length,\n    };\n  }\n  return terms[name].term;\n};\n\nexport const order = (t, p) => {\n  if (isSymbol(t) || typeof t === 'string') {\n    return terms[term(t).description].index * 2;\n  }\n  if (isNot(t)) return order(t[1]) + 1;\n  return (Object.keys(terms).length * (p === t[0] ? 2 : 4)) + t.slice(1).reduce((s, p) => s + order(p), 0);\n};\n\nexport const sortExpr = (exp) => {\n  if (isNot(exp) || isSymbol(exp)) return exp;\n  const [p, ...subs] = exp;\n  const exprs = subs.sort((a, b) => order(a, p) - order(b, p)).map(s => sortExpr(s));\n  // Rewrite the expression\n  if (exprs.some((a) => !isNot(a))) {\n    while (isNot(exprs[0])) {\n      // Rotate until the first arg is not a NOT.\n      // This is so !ABC can be written with SET notation's `\\`, e.g.,\n      // !ABC -> BC!A -> B n C \\ A.\n      // !A!BC -> C \\ A \\ B\n      // What happens if they're all nots?  You get a leading not, that's all,\n      // e.g., !A!B!C -> !A \\ B \\ C\n      // This is technically an empty set, though.\n      exprs.push(exprs.shift());\n    }\n    return [p, ...exprs];\n  }\n  return exp;\n};\n\nexport const invert = (expression) => {\n  if (isNot(expression)) return expression[1];\n  if (expression === TRUE) return FALSE;\n  if (expression === FALSE) return TRUE;\n  return [NOT, expression];\n};\n\nexport const symbolize = (expression) => {\n  if (typeof expression === 'string') return KEYWORDS[expression] ?? term(expression);\n  if (isSymbol(expression)) return expression;\n  if (Array.isArray(expression)) return expression.map(t => symbolize(t));\n  throw new Error(`Invalid expression: ${expression.toString()}`);\n};\n\nexport const getSymbols = (expression) => {\n  const result = new Set();\n  const addExpression = (exp) => {\n    if (isSymbol(exp)) {\n      if (exp === AND || exp === OR || exp === NOT || exp === TRUE || exp === FALSE) {\n        return;\n      }\n      result.add(exp);\n      return;\n    }\n    exp.forEach(e => addExpression(e));\n  };\n  addExpression(symbolize(expression));\n  return Array.from(result);\n};\n\nexport const interpret = (expression) => {\n  if (expression === TRUE) return () => true;\n  if (expression === FALSE) return () => false;\n  if (isSymbol(expression) && !KEYWORDS[expression]) {\n    return (props) => props[expression.description];\n  }\n  if (isExpression(expression)) {\n    if (expression[0] === OR) {\n      const int = expression.slice(1).map(interpret);\n      return (props) => int.reduce((s, t) => s || t(props), false);\n    }\n    if (expression[0] === AND) {\n      const int = expression.slice(1).map(interpret);\n      return (props) => int.reduce((s, t) => s && t(props), true);\n    }\n    const int = interpret(expression[1]);\n    return (props) => !int(props);\n}\n  if (Array.isArray(expression)) {\n    throw new Error(`Unknown operator: ${expression[0].toString()}`);\n  }\n  throw new Error(`Invalid expression: ${expression.toString()}`);\n};\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Nonmonotone_laws (double negation)\n// !!P => P; !!!!P => P; etc.\nexport const involution = (exp) => {\n  while (isNot(exp) && isNot(exp[1])) {\n    exp = exp[1][1];\n  }\n  return exp;\n};\n","import { AND, FALSE, NOT, OR, TRUE } from './consts.mjs';\nimport { isExpression } from './tools.mjs';\n\nexport const SET = Symbol('set notation');\nexport const POLISH = Symbol('polish notation');\nexport const LOGIC = Symbol('logic notation');\nexport const SOURCE = Symbol('pasteable');\n\nlet defaultNotation = SET;\n\nconst toSetString = exp => {\n  if (typeof exp === 'symbol') {\n    return exp.description;\n  }\n  if (isExpression(exp) && exp.length === 1) {\n    return 'Empty set';\n  }\n\n  if (!exp[SET]) {\n    const [operation, ...operands] = exp;\n    const value = operation === NOT\n      ? (toSetString(operation) + toSetString(operands[0]))\n      : `(${operands.map(toSetString).join(toSetString(operation))})`;\n    Object.defineProperty(exp, SET, { value });\n  }\n  return exp[SET];\n};\n\nexport const toPolishString = exp => {\n  if (typeof exp === 'symbol') {\n    return exp.description;\n  }\n  if (isExpression(exp) && exp.length === 1) {\n    return '()';\n  }\n  if (!exp[POLISH]) {\n    const [operation, ...operands] = exp;\n    const value = operation === NOT\n      ? `${toPolishString(operation)}${toPolishString(operands[0])}`\n      : `(${toPolishString(operation).trim()} ${operands.map(toPolishString).join(' ')})`;\n    Object.defineProperty(exp, POLISH, { value });\n  }\n  return exp[POLISH];\n};\n\nexport const toLogicString = exp => {\n  if (exp === TRUE) return '1';\n  if (exp === FALSE) return '0';\n  if (typeof exp === 'symbol') {\n    return exp.description;\n  }\n  if (isExpression(exp) && exp.length === 1) {\n    return '∅';\n  }\n  if (!exp[LOGIC]) {\n    const [operation, ...operands] = exp;\n    let value;\n    if (operation === NOT) {\n      value = `!${toLogicString(operands[0])}`;\n    }\n    if (operation === AND) {\n      value = operands.map(toLogicString).join('');\n    }\n    if (operation === OR) {\n      value = `(${operands.map(toLogicString).join('+')})`;\n    }\n    Object.defineProperty(exp, LOGIC, { value });\n  }\n  return exp[LOGIC];\n};\n\nconst srcMap = {\n  [AND]: 'AND',\n  [OR]: 'OR',\n  [NOT]: 'NOT',\n  [TRUE]: 'TRUE',\n  [FALSE]: 'FALSE',\n};\n\nexport const toSource = (exp) => {\n  if (typeof exp === 'symbol') {\n    return srcMap[exp] ?? exp.description;\n  }\n  if (isExpression(exp) && exp.length === 1) {\n    return 'undefined';\n  }\n  if (!exp[SOURCE]) {\n    Object.defineProperty(exp, SOURCE, {\n      value: `[${exp.map(toSource).join(', ')}]`\n    });\n  }\n  return exp[SOURCE];\n};\n\nconst toString = (exp, mode) => {\n  const m = mode ?? defaultNotation;\n  if (m === SET) {\n    return (\n      toSetString(exp)\n        .replace(/∩ !/g, '∖ ')\n        .replace(/^\\((.*)\\)$/g, '$1')\n    );\n  }\n  if (m === POLISH) {\n    return toPolishString(exp);\n  }\n  if (m === LOGIC) {\n    return (\n      toLogicString(exp)\n        .replace(/^\\((.*)\\)$/g, '$1')\n    );\n  }\n  return toSource(exp);\n};\n\nexport const setNotation = (v) => {\n  defaultNotation = v;\n};\n\nObject.assign(toString, {\n  setNotation,\n  SET,\n  POLISH,\n  LOGIC,\n  SOURCE,\n});\n\nexport default toString;","import { isExpression, isNot } from '../tools.mjs';\n\n// unwrap non-unary ops with one argument.  Do this recursively.\n// (u exp) => exp\n// (n exp) => exp\nconst unwrap = (exp) => {\n  if (!isExpression(exp)) return exp;\n  if (!isNot(exp) && exp.length === 2) return exp[1];\n  return [exp[0], ...exp.slice(1).map(unwrap)];\n};\n\nexport default unwrap;","import { isNot, isSymbol } from \"../tools.mjs\";\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Monotone_laws\n// (∪ (∪ P Q) R) => (∪ P Q R)\n// (∩ (∩ P Q) R) => (∩ P Q R)\nconst association = (exp) => {\n  if (isNot(exp) || isSymbol(exp)) return exp;\n  const [op, ...exprs] = exp;\n  const res = [op];\n  exprs.forEach((se) => {\n    if (se[0] === op) {\n      res.push(...se.slice(1));\n      return;\n    } \n    res.push(se);\n  });\n  return res;\n};\n\nexport default association;\n","import { contains, isAnd, isOr, invert, without } from \"../tools.mjs\";\nimport unwrap from \"./unwrap.mjs\";\n\n// https://en.wikipedia.org/wiki/Absorption_(logic)\n// (∪ P (∩ P Q) ...) <=> (∪ P ...)\n// (∪ (∩ !P Q) P) <=> (∪ P Q)\n// (∪ (∩ P Q) !P) <=> (∪ !P Q)\nconst absorption = (exp) => {\n  if (!isOr(exp)) return exp;\n  let work = exp;\n  for (let pi = 1; pi < work.length; pi++) {\n    const P = work[pi];\n    if (!isAnd(P)) continue;\n    for (let qi = 1; qi < work.length; qi++) {\n      if (qi === pi) continue;\n      const Q = work[qi];\n      const notQ = invert(Q);\n      if (contains(P, Q)) {\n        work = without(work, P);\n      } else if (contains(P, notQ)) {\n        work = [...work];\n        work[pi] = unwrap(without(P, notQ));\n      }\n    }\n  }\n  return work;\n};\n\nexport default absorption;\n","import { AND } from \"../consts.mjs\";\nimport { areEqual, contains, isAnd, isOr, findCommon, invert, sortExpr, without } from \"../tools.mjs\";\n\n// https://en.wikipedia.org/wiki/Consensus_theorem\n// (u (n P Q) (n P !R) (n Q R) ...) => (u (n P !R) (n Q R) ...)\n// The resolvant of (n P !R) and (n Q R) is (n P Q), so it can be removed.\n\nconst findResolvant = (l, r) => {\n  const exclude = [];\n  const terms = [...l.slice(1), ...r.slice(1)];\n  let hasResolvant = false;\n  terms.forEach(P => {\n    const _P = invert(P);\n    if (contains(r, _P)) {\n      exclude.push(P);\n      exclude.push(_P);\n      hasResolvant = true;\n    }\n  });\n  if (!hasResolvant) return null;\n  const resolvant = new Set(terms.filter(P => !exclude.some((p) => areEqual(p, P))));\n  return sortExpr([AND, ...Array.from(resolvant)]);\n};\n\nconst consensus = (exp) => {\n  if (!isOr(exp)) return exp;\n  let work = exp;\n  const ands = exp.slice(1).filter(isAnd);\n  if (ands.length < 3) return exp;\n  const { unique } = findCommon(...ands);\n  const uands = unique ? unique.map((t) => [AND, ...t]) : ands;\n  for (let i = 0; i < uands.length; i++) {\n    for (let j = 0; j < uands.length; j++) {\n      if (i === j) continue;\n      const res = findResolvant(uands[i], uands[j]);\n      if (res) {\n        for (let k = 0; k < uands.length; k++) {\n          if (k === i || k === j) continue;\n          if (areEqual(res, uands[k])) {\n            return without(work, ands[k]);\n          }\n        }\n      }\n    }\n  }\n  return exp;\n};\n\nexport default consensus;\n","import { AND, OR } from \"../consts.mjs\";\nimport { hasOr, isAnd, isOr } from \"../tools.mjs\";\nimport association from \"./association.mjs\";\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Monotone_laws\n// (∩ (∪ A B C) (∪ E F G)) => (u AE BE CE AF BF CF AG BG CG)\n// only do this if the parent node is an OR, and the expression contains ORs\n// This helps us associatively collapse the expression\nconst crossProduct = (exprs1, exprs2) => {\n  const product = [];\n  for (let pi = 1; pi < exprs1.length; pi++) {\n    for (let qi = 1; qi < exprs2.length; qi++) {\n      const res = association([AND, exprs1[pi], exprs2[qi]]);\n      product.push(res);\n    }\n  }\n  return product;\n};\n\nconst distribute = (exp, p) => {\n  if ((isAnd(exp) && p !== AND && hasOr(exp))) {\n    const ors = exp.slice(1).map(a => isOr(a) ? a : [OR, a]);\n    let work = ors.shift();\n    while (ors.length) {\n      work = [OR, ...crossProduct(work, ors.shift())];\n    }\n    return work;\n  }\n  return exp;\n};\n\nexport default distribute;\n","import unwrap from './unwrap.mjs';\nimport { involution } from '../tools.mjs';\nimport tautology from './tautology.mjs';\nimport identity from './identity.mjs';\nimport association from './association.mjs';\nimport complement from './complement.mjs';\nimport deMorgan from './deMorgan.mjs';\nimport absorption from './absorption.mjs';\nimport consensus from './consensus.mjs';\nimport collect from './collect.mjs';\nimport distribute from './distribute.mjs';\n\n// This is called a \"Barrel file\", it collects all the stuff in this directory\n//  into a single object.\n\nexport default {\n  unwrap,\n  involution,\n  tautology,\n  identity,\n  association,\n  complement,\n  deMorgan,\n  absorption,\n  distribute,\n  collect,\n  consensus,\n};\n","import { areEqual, isNot, isSymbol } from \"../tools.mjs\";\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Monotone_laws (idempotence)\n// Eliminate duplicates within expressions.\n//  (o P P ...) => (o P ...)\nconst tautology = (exp) => {\n  if (isNot(exp) || isSymbol(exp)) return exp;\n  const dupes = new Set();\n  for (let p = 1; p < exp.length - 1; p++) {\n    for (let q = p + 1; q < exp.length; q++) {\n      if (areEqual(exp[p], exp[q])) {\n        dupes.add(q);\n      }\n    }\n  }\n  if (dupes.size) {\n    return exp.filter((_, i) => !dupes.has(i));\n  }\n  return exp;\n};\n\nexport default tautology;","import { FALSE, TRUE } from '../consts.mjs';\nimport {\n  isExpression,\n  isNot,\n  isAnd,\n  isOr,\n  contains,\n  without,\n} from '../tools.mjs';\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Monotone_laws (annihilators)\n// (∩ FALSE ...) => FALSE\n// (∩ TRUE ...) => (∩ ...)\n// (∪ TRUE ...) => TRUE\n// (∪ FALSE ...) => (∪ ...)\nconst identity = (exp) => {\n  if (!isExpression(exp) || isNot(exp)) return exp;\n  const hasFalse = contains(exp, FALSE);\n  const hasTrue = contains(exp, TRUE);\n  if (isAnd(exp)) {\n    if (hasFalse) return FALSE;\n    if (hasTrue) return without(exp, TRUE);\n  }\n  if (isOr(exp)) {\n    if (hasTrue) return TRUE;\n    if (hasFalse) return without(exp, FALSE);\n  }\n  return exp;\n};\n\nexport default identity;\n","import { FALSE, TRUE } from \"../consts.mjs\";\nimport { hasComplement, isAnd, isNot, isSymbol } from \"../tools.mjs\";\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Nonmonotone_laws (complementation)\n// (∪ P !P ...) => TRUE\n// (∩ P !P ...) => FALSE\nconst complement = (exp) => {\n  if (isNot(exp) || isSymbol(exp) || !hasComplement(exp)) return exp;\n  if (isAnd(exp)) return FALSE;\n  return TRUE;\n};\n\nexport default complement;\n","import { AND, FALSE, OR, TRUE } from \"../consts.mjs\";\nimport { isAnd, isNot, isOr, invert } from \"../tools.mjs\";\n\n// https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n// !(n ...) => (u !...)\n// !(u ...) => (n !...)\n// !TRUE => FALSE\n// !FALSE => TRUE\nconst deMorgan = (exp) => {\n  if (!isNot(exp)) return exp;\n  const inner = exp[1];\n  if (inner === TRUE) return FALSE;\n  if (inner === FALSE) return TRUE;\n  const a = isAnd(inner);\n  const o = isOr(inner);\n  if (!(a || o)) return exp;\n  return [a ? OR : AND, ...inner.slice(1).map(invert)];\n};\n\nexport default deMorgan;\n","\n\nimport { AND, OR } from \"../consts.mjs\";\nimport { areEqual, hasAnd, hasComplement, isAnd, isOr, findCommon, without } from \"../tools.mjs\";\nimport absorption from \"./absorption.mjs\";\n\n// https://en.wikipedia.org/wiki/Boolean_algebra#Monotone_laws\n// (∪ (∩ P Q) (∩ P R)) => (∩ P (∪ Q R))\n// Do this only if this is an OR and the parent is an AND or top-level (null)\nconst collect = (exp, p) => {\n  if (!(isOr(exp) && p !== OR)) return exp;\n  if (!hasAnd(exp)) return exp;\n  const ands = exp.slice(1).filter(isAnd);\n  for (let pi = 0; pi < ands.length - 1; pi++) {\n    for (let qi = pi + 1; qi < ands.length; qi++) {\n      const { common, unique } = findCommon(ands[pi], ands[qi]);\n      if (!common) continue;\n      const others = without(without(exp, ands[pi]), ands[qi]);\n      // It's possible that left and right are each other's complements\n      const u = unique.map((t) => t.length === 1 ? t[0] : [AND, ...t]);\n      const uQR = [OR, ...u];\n      if (!(\n        // Potential advantage 1: we reduce to a single AND and parent is an AND,\n        //  so we'll be able to associate upwards\n        //  e.g., A & ((B & A) | (B & C)) => A & B & (A | C)\n        (others.length === 1 && p === OR)\n        // Advantage 2: collected expression contains a complement, which can be\n        //  eliminated to a single bool, then identitied out\n        //  e.g., (B & C) | (B & !C) => B & (C | !C) => B & TRUE => B\n        || hasComplement(uQR)\n        // Advantage 3: collected expression will absorb\n        // e.g., (!A & B) | A => B | A\n        || !areEqual(uQR, absorption(uQR))\n      // No advantages? try the next pair.\n      )) continue;\n      const group = [AND, ...common, uQR];\n      if (others.length > 1) {\n        return [...others, group];\n      }\n      return group;\n    }\n  }\n  return exp;\n};\n\nexport default collect;\n","import { areEqual, isExpression, isSymbol, sortExpr, term } from './tools.mjs';\nimport toString, { LOGIC, POLISH, SET, SOURCE } from \"./toString.mjs\";\nimport transforms from './transforms/index.mjs';\nexport * from './consts.mjs';\nexport * from './tools.mjs';\n\nexport { term, toString, LOGIC, POLISH, SET, SOURCE };\n\n// Turn on for debugging...\nlet LOG = false;\nlet depth = 0;\n\nconst simplifySubexpressions = exp => {\n  // Non-expressions do not have subexpressions\n  if (!isExpression(exp)) return exp;\n  // Indent output by 1 so the developer has some sense of how deep the subexpression is\n  depth += 1;\n  // Our expressions are of the form [operation, ...operands] - a kind\n  //  of simple polish notation that matches really well with arrays.\n  //  So, what this line does is replace [operation, ...operands] with\n  //  [operation, ...simplifiedOperands]\n  const r = [exp[0], ...exp.slice(1).map(se => simplify(se, exp[0]))];\n  depth -= 1;\n  return r;\n};\n\n// Hackery.  `Array(n + 1).join(str)` will repeat `str` `n` times\nconst indent = () => new Array(depth + 1).join('  ');\n\nconst pass = (exp, p) => {\n  // Symbols cannot be further simplified\n  if (isSymbol(exp)) return exp;\n  // Normalize the expression by simplifying its children and ordering it consistently.\n  exp = sortExpr(simplifySubexpressions(exp));\n  // Loop through the transforms\n  const names = Object.keys(transforms);\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    // Try applying the transform\n    const r = transforms[name](exp, p);\n    // When we find one that does something\n    if (!areEqual(exp, r, false)) {\n      // Log the change if asked to\n      if (LOG) {\n        console.log(`${indent()}${name}${p ? `(${p.description.trim()})` : ''}: ${toString(exp)} -> ${toString(r)}`);\n      }\n      // Normalize and order it, and return the result, so the outer simplifier\n      //  can start again.\n      return sortExpr(simplifySubexpressions(r));\n    }\n  }\n  return exp;\n};\n\nexport const simplify = (exp, p = null) => {\n  // Symbols cannot be simplified\n  if (isSymbol(exp)) return exp;\n  let next;\n  // Keep going until a pass does not change the expression\n  while (!areEqual(next, exp)) {\n    exp = next ?? exp;\n    next = pass(exp, p);\n  }\n  // return the final simplification.\n  return next;\n};\n\nsimplify.log = v => {\n  LOG = v;\n};","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { LooseExpression: peg$parseLooseExpression },\n      peg$startRuleFunction  = peg$parseLooseExpression,\n\n      peg$c0 = function(expr) { return expr; },\n      peg$c1 = \"(\",\n      peg$c2 = peg$literalExpectation(\"(\", false),\n      peg$c3 = \")\",\n      peg$c4 = peg$literalExpectation(\")\", false),\n      peg$c5 = \"[\",\n      peg$c6 = peg$literalExpectation(\"[\", false),\n      peg$c7 = \"]\",\n      peg$c8 = peg$literalExpectation(\"]\", false),\n      peg$c9 = function(f) { return ['NOT', f] },\n      peg$c10 = function(op, operands) {\n          if (op === 'AND_NOT' || op === 'OR_NOT') {\n            return [\n              op.replace(/_NOT$/, ''),\n              operands[0],\n              ...operands.slice(1).map(t => ['NOT', t])\n            ];\n          }\n          return [op, ...operands];\n        },\n      peg$c11 = function(o, t) { return [o, t]; },\n      peg$c12 = function(head, tail) {\n          return (\n            tail.length === 0\n            ? head\n            : ['OR', head, ...tail.map((e) => e[0] === 'OR_NOT' ? ['NOT', e[1]] : e[1])]\n          );\n       },\n      peg$c13 = function(o, t) { return [o ? o[1] : 'AND', t]; },\n      peg$c14 = function(head, tail) {\n          return (\n            tail.length === 0\n            ? head\n            : ['AND', head, ...tail.map((e) => e[0] === 'AND_NOT' ? ['NOT', e[1]] : e[1])]\n          );\n        },\n      peg$c15 = /^[Tt]/,\n      peg$c16 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c17 = /^[Rr]/,\n      peg$c18 = peg$classExpectation([\"R\", \"r\"], false, false),\n      peg$c19 = /^[Uu]/,\n      peg$c20 = peg$classExpectation([\"U\", \"u\"], false, false),\n      peg$c21 = /^[Ee]/,\n      peg$c22 = peg$classExpectation([\"E\", \"e\"], false, false),\n      peg$c23 = \"\\u22A4\",\n      peg$c24 = peg$literalExpectation(\"\\u22A4\", false),\n      peg$c25 = \"1\",\n      peg$c26 = peg$literalExpectation(\"1\", false),\n      peg$c27 = \"\\u25A0\",\n      peg$c28 = peg$literalExpectation(\"\\u25A0\", false),\n      peg$c29 = function() { return 'TRUE'; },\n      peg$c30 = /^[Ff]/,\n      peg$c31 = peg$classExpectation([\"F\", \"f\"], false, false),\n      peg$c32 = /^[Aa]/,\n      peg$c33 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c34 = /^[Ll]/,\n      peg$c35 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c36 = /^[Ss]/,\n      peg$c37 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c38 = \"0\",\n      peg$c39 = peg$literalExpectation(\"0\", false),\n      peg$c40 = \"\\u22A5\",\n      peg$c41 = peg$literalExpectation(\"\\u22A5\", false),\n      peg$c42 = \"\\u25A1\",\n      peg$c43 = peg$literalExpectation(\"\\u25A1\", false),\n      peg$c44 = function() { return 'FALSE'; },\n      peg$c45 = /^[A-Za-z]/,\n      peg$c46 = peg$classExpectation([[\"A\", \"Z\"], [\"a\", \"z\"]], false, false),\n      peg$c47 = function(S) { return S; },\n      peg$c48 = /^[Nn]/,\n      peg$c49 = peg$classExpectation([\"N\", \"n\"], false, false),\n      peg$c50 = /^[Dd]/,\n      peg$c51 = peg$classExpectation([\"D\", \"d\"], false, false),\n      peg$c52 = \"&&\",\n      peg$c53 = peg$literalExpectation(\"&&\", false),\n      peg$c54 = \"&\",\n      peg$c55 = peg$literalExpectation(\"&\", false),\n      peg$c56 = \"*\",\n      peg$c57 = peg$literalExpectation(\"*\", false),\n      peg$c58 = \"n\",\n      peg$c59 = peg$literalExpectation(\"n\", false),\n      peg$c60 = \"\\u2229\",\n      peg$c61 = peg$literalExpectation(\"\\u2229\", false),\n      peg$c62 = \"\\u2227\",\n      peg$c63 = peg$literalExpectation(\"\\u2227\", false),\n      peg$c64 = \"^\",\n      peg$c65 = peg$literalExpectation(\"^\", false),\n      peg$c66 = \"\\xB7\",\n      peg$c67 = peg$literalExpectation(\"\\xB7\", false),\n      peg$c68 = function() { return 'AND'; },\n      peg$c69 = \"\\u2216\",\n      peg$c70 = peg$literalExpectation(\"\\u2216\", false),\n      peg$c71 = \"\\\\\",\n      peg$c72 = peg$literalExpectation(\"\\\\\", false),\n      peg$c73 = function() { return 'AND_NOT'; },\n      peg$c74 = /^[Oo]/,\n      peg$c75 = peg$classExpectation([\"O\", \"o\"], false, false),\n      peg$c76 = \"||\",\n      peg$c77 = peg$literalExpectation(\"||\", false),\n      peg$c78 = \"|\",\n      peg$c79 = peg$literalExpectation(\"|\", false),\n      peg$c80 = \"\\u2225\",\n      peg$c81 = peg$literalExpectation(\"\\u2225\", false),\n      peg$c82 = \"+\",\n      peg$c83 = peg$literalExpectation(\"+\", false),\n      peg$c84 = \"u\",\n      peg$c85 = peg$literalExpectation(\"u\", false),\n      peg$c86 = \"\\u222A\",\n      peg$c87 = peg$literalExpectation(\"\\u222A\", false),\n      peg$c88 = \"\\u2228\",\n      peg$c89 = peg$literalExpectation(\"\\u2228\", false),\n      peg$c90 = \"v\",\n      peg$c91 = peg$literalExpectation(\"v\", false),\n      peg$c92 = function() { return 'OR'; },\n      peg$c93 = \"-\",\n      peg$c94 = peg$literalExpectation(\"-\", false),\n      peg$c95 = function() { return 'OR_NOT'; },\n      peg$c96 = \"!\",\n      peg$c97 = peg$literalExpectation(\"!\", false),\n      peg$c98 = \"~\",\n      peg$c99 = peg$literalExpectation(\"~\", false),\n      peg$c100 = \"\\xAC\",\n      peg$c101 = peg$literalExpectation(\"\\xAC\", false),\n      peg$c102 = function() { return 'NOT'; },\n      peg$c103 = peg$otherExpectation(\"optional whitespace\"),\n      peg$c104 = /^[ \\t\\n\\r]/,\n      peg$c105 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n      peg$c106 = peg$otherExpectation(\"required whitespace\"),\n      peg$c107 = \",\",\n      peg$c108 = peg$literalExpectation(\",\", false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseLooseExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsePolishExpression();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseExpression();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseExpression() {\n    var s0;\n\n    s0 = peg$parseUnion();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseGroup();\n    }\n\n    return s0;\n  }\n\n  function peg$parseGroup() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c1;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c2); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLooseExpression();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s3 = peg$c3;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseLooseExpression();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseTerseInversion() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseInvertOperation();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseTerm();\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInversion() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseInvertOperation();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseGroup();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseSymbol();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseBoolean();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseInversion();\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c9(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePolishOperand() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSeparator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseExpression();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePolishExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseOperation();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsePolishOperand();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsePolishOperand();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c10(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnionPart() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseUnionOperation();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseIntersection();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11(s2, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnion() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIntersection();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseUnionPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseUnionPart();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c12(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTerm() {\n    var s0;\n\n    s0 = peg$parseGroup();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseInversion();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseBoolean();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseSymbol();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIntersectionPart() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parse_();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseIntersectionOperation();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseTerm();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIntersection() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseTerm();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseIntersectionPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseIntersectionPart();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c14(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseBoolean() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c15.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c16); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c19.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c20); }\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c21.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n          if (s5 !== peg$FAILED) {\n            s2 = [s2, s3, s4, s5];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 8868) {\n        s1 = peg$c23;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 49) {\n          s1 = peg$c25;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c26); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 9632) {\n            s1 = peg$c27;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c29();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c30.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s2 !== peg$FAILED) {\n        if (peg$c32.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c33); }\n        }\n        if (s3 !== peg$FAILED) {\n          if (peg$c34.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c35); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s5 !== peg$FAILED) {\n              if (peg$c21.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c22); }\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 48) {\n          s1 = peg$c38;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8869) {\n            s1 = peg$c40;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 9633) {\n              s1 = peg$c42;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c44();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSymbol() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c47(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseOperation() {\n    var s0;\n\n    s0 = peg$parseIntersectionOperation();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseUnionOperation();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseInvertOperation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIntersectionOperation() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c32.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c33); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c48.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c52) {\n        s1 = peg$c52;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 38) {\n          s1 = peg$c54;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c56;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c57); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 110) {\n              s1 = peg$c58;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8745) {\n                s1 = peg$c60;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 8743) {\n                  s1 = peg$c62;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 94) {\n                    s1 = peg$c64;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c65); }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 183) {\n                      s1 = peg$c66;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c68();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 8726) {\n        s1 = peg$c69;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c71;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c72); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c73();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnionOperation() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c74.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c75); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c76) {\n        s1 = peg$c76;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c77); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s1 = peg$c78;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c79); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8741) {\n            s1 = peg$c80;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c81); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s1 = peg$c82;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c83); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 117) {\n                s1 = peg$c84;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c85); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 8746) {\n                  s1 = peg$c86;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c87); }\n                }\n                if (s1 === peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 8744) {\n                    s1 = peg$c88;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c89); }\n                  }\n                  if (s1 === peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 118) {\n                      s1 = peg$c90;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c91); }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c92();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c93;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c94); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c95();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInvertOperation() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c48.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c49); }\n    }\n    if (s2 !== peg$FAILED) {\n      if (peg$c74.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c75); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c15.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c16); }\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c96;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c97); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 126) {\n          s1 = peg$c98;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c99); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 172) {\n            s1 = peg$c100;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c101); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c102();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c104.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c105); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c104.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c105); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c103); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c104.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c105); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c104.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c105); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c106); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSeparator() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$parse__();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c107;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c108); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport default {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","import parser from './boolGrammar.mjs';\nimport { symbolize } from './tools.mjs';\nexport const parse = (str) => symbolize(parser.parse(str));\n"],"names":["AND","_OPERATORS","_srcMap","Symbol","OR","TRUE","FALSE","KEYWORDS","NOT","OPERATORS","isExpression","exp","Array","isArray","isOr","isNot","isSymbol","expression","subexpression","slice","some","se","areEqual","e1","e2","inv","_map","map","e","involution","length","p","i","P","q","invert","notQ","hasAnd","isAnd","findCommon","exps","call","arguments","nExps","terms","forEach","ei","t","item","push","filter","T","unique","reduce","r","where","_ref2","common","sub","concat","name","description","term","index","Object","keys","order","s","exprs","sort","a","b","shift","symbolize","toString","getSymbols","result","add","addExpression","from","interpret","props","int","_int","_int2","Error","SET","POLISH","SOURCE","defaultNotation","toSetString","operation","operands","value","join","defineProperty","toPolishString","trim","toLogicString","LOGIC","srcMap","toSource","_srcMap$exp","mode","m","replace","assign","setNotation","v","unwrap","association","op","res","apply","absorption","pi","work","qi","Q","contains","without","findResolvant","l","exclude","_P","hasResolvant","resolvant","Set","sortExpr","crossProduct","exprs1","exprs2","product","transforms","tautology","dupes","size","_","has","identity","hasFalse","hasTrue","complement","hasComplement","deMorgan","inner","o","distribute","hasOr","ors","collect","ands","_findCommon","others","u","uQR","group","consensus","uands","j","k","simplifySubexpressions","depth","simplify","pass","names","LOG","console","log","next","_next","peg$SyntaxError","message","expected","found","location","this","captureStackTrace","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","parts","escapedParts","classEscape","inverted","any","end","other","hex","ch","charCodeAt","toUpperCase","descriptions","type","describeExpected","describeFound","parser","input","options","peg$FAILED","peg$result","startPos","endPos","startPosDetails","endPosDetails","peg$startRuleFunctions","LooseExpression","peg$parseLooseExpression","peg$startRuleFunction","peg$c2","peg$literalExpectation","peg$c4","peg$c6","peg$c8","peg$c15","peg$c16","peg$classExpectation","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c24","peg$c26","peg$c28","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c39","peg$c41","peg$c43","peg$c45","peg$c46","peg$c48","peg$c49","peg$c50","peg$c51","peg$c53","peg$c55","peg$c57","peg$c59","peg$c61","peg$c63","peg$c65","peg$c67","peg$c70","peg$c72","peg$c74","peg$c75","peg$c77","peg$c79","peg$c81","peg$c83","peg$c85","peg$c87","peg$c89","peg$c91","peg$c94","peg$c97","peg$c99","peg$c101","peg$c103","peg$otherExpectation","peg$c104","peg$c105","peg$c106","peg$c108","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$fail","s0","s2","peg$parse_","s1","s3","peg$parseIntersectionOperation","peg$parseUnionOperation","peg$parseInvertOperation","peg$parseOperation","peg$parsePolishOperand","peg$parsePolishExpression","peg$parseExpression","head","tail","peg$parseIntersection","peg$parseUnionPart","peg$parseUnion","peg$parseGroup","peg$parseInversion","peg$parseSymbol","peg$parseBoolean","test","charAt","peg$parse__","peg$parseSeparator","s4","peg$parseTerm","peg$parseIntersectionPart","s5","s6","substr","start","offset","parse","str"],"mappings":"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"}